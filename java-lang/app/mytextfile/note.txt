6/29------------------------------------------------------------------------------------
<인터프리터 언어>
소스파일을 읽어서 실행, 실행속도가 느리다.
명렁어를 실행하기 전에는 명렁문에 오류가 있는지 알수 없다.- 버그가 발견되기 어려움
소스코드가 노출 > 프로그래밍 자산 보호 불가능

<자바>
Hybrid 프로그래밍 > 컴파일형식+인터프리트형식
자바 캐치프레이즈>>> write once, run anywhere > 한번만 작성하고, 어디서든 작동함 >>>> 인터프리터 언어의 장점
:
문법오류 검사,
[명령문 최적화>실행명령수가 감소>실행속도향상],
[가상기계어로 변환>소스노출을 막음>프로그래밍 자산을 보호],

bytecode player = java runtime = **JVM**(Java Virtual Machine)
-------------------------------------------------
Bytecode 실행 한계 극복
JIT(Just-In-Time)컴파일 : 실행할 일부 코드를 뭉텅이로 가져와서 기계어로 변환하고 즉시 실행.
<<----->>
// ART(Android Run Time) AOT(Ahead Of Time)컴파일 : 안드로이드에 주로 씀>>앱 설치할때 모든 코드를 기계어로 변환 후 저장함.
------------------------------------------------
Emulator(변환기) : 다른타입의 언어를 맞는 언어로 변환해 줌 ex.(intel>>ARM 변환기)
<JDK 종류>
Open JDK > Oracle JDK > GraalVM
         > IBM JDK
         > Amazon JDK
         > Azul JDK
------------------------------------------------

자바 문법 : 기본 구조
* 소스파일-클래스 블록-.class 파일
* 공개(public)로 설정된 클래스 블록인 경우 파일명은 클래스 블록 이름과 같아야 한다. >> public class는 단 하나만 존재함
6/30--------------------------------------------------------------------------------------
*entry point : main(){~~} : 진입점
jVM이 명령문 실행을 시작하는 곳
>>
class Exam03 {
    public static void main(String[]args) {
        __명령문__
    }
}
>> 의 형식을 가진다
--------------------------------------------
*자바 문법
1) literal //데이터 표기법
2) variable //메모리 준비
3) operators //데이터 연산자
4) 흐름제어문 //조건, 반복문
5) 메소드 //명령어 묶음
6) 클래스 //메소드 묶음
-----------------------
*literal : 데이터 표기법
6  = 0b0110 (=0B0110) (2진수) //b:binary
10 = 012 (8진수) //0:octa
18 = 0x12 (= 0X12) (16진수)
----------
고정 소수점 : 3.14
부동 소수점 : 31.4^10^-1 = 31.4E-1 = 31.4e-1
----------
논리값 : true false //대소문자 구분
----------
문자 : 'A' '가' //UTF : Unicode TransForm
encoding(~형식화 하라=코드화) <-> decoding(~로 복원하라) //코드화 한걸 풀어 = codec (=en*co*ding + *dec*oding)
//동영상 압축 방법 : MPEG, H.264, ...VP9 //방법 : algorithm
----------
문자열 : "ABCDE", "가나다", --> double quotation 사용! (single quotation 은 안됨) + "" = 빈 '문자열' // '' = 빈 문자...가!!! 아니다!!! 오류임!! // " " = ' ' = 스페이스 문자
single quotation은 문자 '하나'만 가능! // 'a'는 문자, "a"는 문자열
----------
*주석은 컴파일에서 제외된다.(=.class파일에 포함되지 않는다. = .class의 크기와는 상관 없음) : 코드에 대한 부가설명(자신이나 다른 개발자의 이해를 돕기위해)
// : 한 줄 주석 : 줄 끝 까지
/* ....~~~.... */ : 여러줄 주석
----------
*variables : 메모리를 준비시키는 명령문 (메모리를 준비시키는 이유 : 데이터를 저장하기 위해)
저장할 데이터의 유형(data type), 메모리를 가리키는 이름(variable name)
ex) int age; //int : data type, age : variable name
ㄴ=> 정수값을 담을 4byte 크기의 메모리를 준비하라! >> 준비된 메모리를 지금부터 age라 부르겠다., ; : 문장의 끝 표시
**'메모리를 준비시키는 명령문'을 '변수 선언(=variable declaration)'이라 부른다.**
----------
*data type : (자바언어에서 기본으로 제공하는 데이터타입=**primitive data type**=자바 원시 데이터타입=자바 기본 데이터타입)
|| 정수(integer) --------> [1byte:byte], [2byte:short], [4byte:int], [8byte:long]
||부동소수점(floating point) --------> [4byte:float], [8yte:double]
||논리(boolean) ---------> [4byte메모리 기본사용:boolean(배열을 만들 때는 1byte로 만든다.)]
||문자(character) --------> [2byte:char] >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> 이 네 종류가 java primitive data type
문자열(string) ---------> [객체:String] >>>>>>>>>>>>>>>>>>>>>>>>>> 클래스
-----------------------
*변수선언
---------
*Assignment 연산자 : 변수(준비한 메모리)에 값 저장 :
변수명/*(메모리이름=변수선언할 때 지정한 이름)*/ =/*(assignment operation=할당연산자)*/ 값/*리터럴, 변수명 가능*/; //== : equal 연산자
ex1) int a;
a=100; //100 : 정수 리터럴 값
ex2) int b;
b=a; //a변수에 들어있는 **값인 100**을 b변수에 저장하라!
-------------
*메모리 크기와 값의 범위
byte b;
b = 값;
여기서 값은 -128 ~ +127 의 범위
-------------
*메모리크기와 값 저장
ms949? cpu949? -- 검색해보기
-------------
*정수를 2진수로 표현하는 다양한 방법
1) sign-Magnitude : 부호1bit, magnitude(절대값) 나머지 bit : 부동소수점을 2진수로 바꾸는 과정에서 가수부를 표현할때 사용!!
2) 1's 보수 : 안씀!!
    +4 = 0100
    -4 = 0100 에 대해 1의 보수 (보수 : 그 수가 되기 위해 보충해줘야 하는 수) 를 취해서
         1011 이 -4가 된다. //overflow 수는 버린다!!
3) 2의 보수 : 자바에서 정수를 2진수로 바꿀때 사용하는 규칙!! (+대부분의 프로그래밍 언어가 이 규칙 사용)
    +4 = 0100
    -4 : 0100 에 대해 1의 보수해서 1011
        에 다시 1을 더해서 1100
4) Excess -k : 초과하다 bias(여분으로 초과하는 값) : 부동소수점을 2진수로 바꾸는 과정에서 지수부를 표현할 때 사용!!
    +4 : 4 + 128 = 132 >> 132를 2진수로 >> 10000100
    -4 : -4 + 128 = 124 >> 124를 2진수로 >> 01111100
    
    k값은 2^(비트수-1)-1 = 2^(4-1)-1 = 8-1 = 7 (4bit메모리 기준)
    따라서
    +4 >> 4+7 = 11 >> 1011
    -4 >> -4+7 = 3 >> 0011
7/1--------------------------------
*부동소수점을 2진수로 표현하는 방법 >>> IEEE-754 규칙
12.375
12 --> 1100
0.375 --> 0.375*2=0.75 --> 0
        0.75*2=1.5 --> 1
        0.5*2=1.0 --> 1
    ==>> 0.011
===>>> 12.375 = 1100.011 = 1.100011 * 2^3
>> 소수 왼쪽은 무조건 1임 그래서 버림
>> 부호비트 1비트 +:0, -:1
>> 지수(exponent)부 8비트 : Excess-k 규칙에 따라 2진수화 시킨다.
>> 가수(mantissa)부 23비트 --> sign-magnitude 규칙에 따라 2진수로바꾼다.

*2진수와 16진수의 관계
2진수 4bit면 16진수로 바꿈
-------------------------------
*문자를 2진수로 표현하는 방법
1. ASCII : **미국표준**
7bit로 정의 >> 최대 128자

2. (1.)+유럽문자 : ISO-8859-1 (ISO-latin-1) : 8bit >> 최대 256자 : 영어, 숫자, 특수문자 + 유럽문자 : **국제표준**

3. EUC-KR (KSC-5601) : 2byte : **국제표준**
> 영어 : ISO-8859-1 : 1byte
> 한글 : 2byte
가 >> 1011 0000 1010 0001 >> B0A1
각 >> 1011 0000 1010 0010 >> B0A2
똘 >> 1011 0110 1100 1010 >> B6CA
똠 >> x
똥 >> 1011 0110 1100 1011 >> B6CB
>>>> 최대 65536자, 한글은 2350자, 나머지는 일본, 중국어, ...

4. 조합형 : 2byte : **기업이 만들었고 국가표준이지만 국제표준은 아님**
[초성]
ㄱ >> 00010
ㄲ >> 00011
ㄴ >> 00100
...

[중성]
ㅏ >> 00011
ㅐ >> 00100
ㅑ >> 00101
...

[종성]
ㄱ >> 00010
ㄲ >> 00011
ㄳ >> 00100
...

댄 = 1 00101 00100 00101 >> 1001 0100 1000 0101 >> 0x9485

5. MS949(CP949) : 2byte = [EUC-KR] + [약 8천자] 규칙을 추가 // 개 어거지로 추가함 ㅋ
>> 11172자 정의 >> 현재 쓰고 있음 >> ANSI

6. Unicode (2byte, 4byte) //java는 2바이트 씀 >> = UTF-16
A >> 0041
B >> 0042
가 >> AC00
각 >> AC01
...
: 한글11172자 + 옛한글, ...

A >>BE>> 0041 >>LE>> 4100
각 >>BE>> AC01 >>LE>> 01AC

>>> 영어권 입장에서는 데이터 2배로 많이 써서 문제제기


7. UTF-8 : 유니코드 변형 규칙 : 8bit로 표현할 수 있는 문자는 예전처럼 그대로 8bit로 표현하기 >> 그 외 문자는 규칙에 따라 변형하자!
    >> 한글은 2byte 였는데 3byte로 늘어나버림
    가 >> AC00 >> 1010 1100 0000 0000 (UNICODE)
        >>  1110 ~~~~ 10~~~~~~ 10~~~~~~
        >> 1110 1010 1011 0000 1000 0000 (UTF-8)
        >> E A B 0 8 0 >> 0xEAB080

>>> 그러나 JVM이 문자를 저장할 때는 unicode를 쓴다. 그러나 국제표준은 UTF-8을 쓴다.
    일반적으로 텍스트를 저장할 때는 UTF-8을 쓴다.
---------------
*텍스트 와 바이너리
text : .txt, .java, .html, .css, .js, .xml ==>> 문자변환규칙에 따라 저장된 파일 >> 메모장으로 편집가능!
binary : .doc, .hwp, .pdf, .avi, .mp3, .jpg, .gif ==>> 전용 S/W를 통해서만 편집가능!

위에서 말한 문자변환규칙 = character set (= 문자집합)
----------------------------------------------------------
*논리값을 2진수로 표현하는 법
true --> 0000 0001 (1)
false --> 0000 0000 (0)
>> 4byte로 저장한다!

단! 배열인 경우 : 1byte만 사용함!
true --> 01
false --> 00
7/4-----------------------------------------------------------------------------
java se(standard edition) 가 있어야 java ee(enterprise edition)도 이용가능함.
-----------------------------
<windows용>  ==> <mac용>
dir >> ls
%PATH% >> $PATH // % % 인데 $만 씀
---------------------------
nano .zshrc
export JAVA_HOME=`/usr/libexec/java_home -v 17` <<=== ~표시임 따옴표 아님 = "backtick"
# ~~~~~~ ==>> 주석이라는 뜻
export PATH=${JAVA_HOME}/bin:$HOME/bin:/usr/local/bin:$PATH
^X ==>> 컨트롤 키 누르고 X 하라는 뜻 // Exit와 같다
echo $JAVA_HOME  // 경로나옴
echo $PATH // PATH 경로나옴
javac -version
java -version
--------------------------
// JAVA_HOME 환경변수 설정하는 이유 : 일부 java app은 실행할 때 jdk나 jre가 설치된 폴더의 위치를 조회하는 경우가 있다.
// PATH 환경변수에 프로그램 폴더 경로를 등록하는 이유 : 명령 프롬프트의 디렉토리 위치에 상관없이 자바 개발도구를 실행할 수 있도록 하기 위함.
7/5---------------------------------------------------------------------------
JDK : Java Development Kit
JRE : Java Runtime Environment
------------------------------------------------
git clone https://github.com/cornchiplick/bitcamp-study // github.com에 있는 repo를 local로 복제해옴.
git add Hello.java // 백업 명단에 파일을 등록한다. (=staged 상태)
    파일명 옆에 U : Untracked : 아직 업로드되지 않음
    파일명 옆에 A : ??? : 인덱스에 추가됨
    파일명 옆에 M : Modify : 수정되었다는 뜻
git add . // 현재 폴더부터 하위폴더까지 뒤져서 새로 추가되는걸 전부 git add함
git commit -m "백업이유" // 백업 명단에 등록된 파일이나 폴더를 로컬저장소에 백업한다. (=snapshot 상태)
    오류시 :
    git config --global user.email "ilsunkiss@gmail.com"
    git config --global user.name "cornchiplick"
git push // 로컬저장소에 백업한 내용을 git의 repo에 백업한다.
    username : github 계정명
    password : personal access token 보안코드 마우스 우클릭으로 입력 (입력해도 투명해서 안보임) // github의 settings-devoper settings-personal access tokens
최초에 git clone 하고난 이후에는 git pull
------------------------------------------
Hello.java : 자바언어로 작성한 명령문이 들어있음. : 소스파일(source)
Hello.class : Bytecode(= portable code = p-code = os에 관계없이 여기저기서 적용할 수 있다. 라는 뜻) : (클래스파일 = 목적파일)

cmd 에서
    Hello.class
즉시 실행할 수 없다. 완전한 기계어가 아니기 때문에
Hello.class파일을 기계어로 바꿔주려면 JVM(Java.exe)이 필요하다
    java.exe Hello
를 해야한다. 이때 .class를 쓰면 안된다!, 패키지 네임과 혼동할까봐..?
--------------------------------
m1(), m2(), ... 를 모아서 classA, classB, ...를 만들었고
이걸 모아서 폴더에 분리 : 폴더(=패키지 in java, =네임스페이스 in C++)
요즘은 monolotic system에서 micro-service 로 바뀌고 있음 : class보다 method(=functional program)로 쪼개서 나중에 합치기 때문
--------------------------------
bitcamp-study/
    src/Hello.java
    bin/Hello.java
==>> $ javac -d bin -encoding UTF-8 src/Hello.java
        -d bin : .class 파일을 둘 폴더를 지정!! // -d : 디렉토리
        src/Hello.java : src폴더 밑에 있는 Hello.java라는 뜻 : 이름을 마음대로 할 수 있지만 관례상(convention!!!!!) src 폴더라고 한다.(무조건)
==>> $ java -classpath bin Exam09
    -classpath = -cp : 현재폴더에서 다음 경로를 찾아서 그 안에 있는걸 실행해라
--------------------------------
*프로젝트 분리 : 한개의 깃 저장소에 여러 개의 프로젝트 만들기
bitcamp-study/ : 깃 저장소
    java-lang/
        src/Hello.java
        bin/Hello.class
-------------------------------------------------------
깃저장소-project(root)-project(sub)
eomcs-java-lang\app\src\main\java/Hello2.java
~~main/java/com/lang/

-------------------------------------
*자바 호환(compatible)언어
    .java >> .class
    .kt >> .class : 요즘 안드로이드 개발언어
    .groovy >> .class
7/6-------------------------------------------------------------------------------------
*Maven 표준 프로젝트 디렉토리 구조
    프로젝트 = app 만들기 << [소스, 그림, 동영상, 사진, 소리, 설정정보, ...] << 체계적으로 관리

<convention : 국제 공통 관리 체계>

    src/ <<< app제작에 관련된 파일을 두는 폴더
        main/ <<< app 관련 파일을 두는 폴더
            java/ <<< java 소스 파일을 두는 폴더
            resources/ <<< 설정 파일이나 기타 파일을 두는 폴더
        test/ <<< 제작한 app 소스를 테스트하는 파일을 두는 폴더
            java/ <<< 단위 테스트 자바 소스파일을 두는 폴더
            resources/ <<< 단위 테스트할 때 사용할 테스트에 관련된 설정파일 등을 두는 폴더
-------------------------------------------
*자바 패키지 : 자바 소스 파일의 역할에 따라 관리하기 쉽게 여러개의 폴더에 분류, 배치하는 것 = 자바 소스 파일을 역할에 따라 분류한 하위 폴더
            java/ <<< 패키지가 아니다!!
                io/ <<< 패키지임
                db/ <<< 패키지임
                ui/ <<< 패키지임
*자바 패키지 디렉토리 구조 :
    회사(또는 조직)도메인명/제품명(서비스명)/역할/

    회사도메인명 : 전세계에서 유일, 다른회사와 중복될 일이 없다
    ex) com/
            microsoft/
            bitcamp/
        : 상위조직에서 하위조직 순으로 디렉토리 계층을 구성

* 자바 패키지를 class안에서 표현할 때는 .으로 구분한다. (ex) package com.eomcs.lang.ex01)
--------------------------
*자바패키지와 컴파일, 실행 의 관계
[package x.y.z;] 인 [class Exam03.java] 에 대해서
    java -cp bin x.y.z.Exam03 : 가능 >>> 주류임
    java -cp bin x/y/z/Exam03 : 가능 >>> 쓰지마셈
    java -cp bin/x/y/z Exam03 : 불가능 >>> 패키지네임까지 완벽하게 불러주셈 그걸안해서 틀린거임
    (x/y/z폴더에서 끄집어낸 후) java -cp bin Exam03 : 불가능 >>> 패키지에 소속되어 있는데 그 밖으로 나오면 걍 안됨
즉, -d bin은 패키지폴더를 자동 생성해줌
즉, Exam03.java 파일도 마찬가지로 x/y/z 디렉토리 안에 위치시킬것! 안그래도 되지만 관례입니다~
즉, 일반폴더와 패키지가 시작되는 부분이 구분되어있다.
즉, 패키지에 소속될 경우,
    1. 소스파일 첫 명령으로 package를 지정해야 한다.
    2. 소스파일도 관리하기 쉽게 패키지에 해당하는 폴더에 두어야 한다.
즉,
    1. 컴파일하게 되면 패키지에 해당하는 폴더에 .class파일이 놓인다.
    2. 클래스이름을 지정할때 패키지명도 함께 지정해야한다.
******------------------------------------------------------------------------------******
*프로젝트 시작준비하기
main()메소드가 들어있는 class는 단 하나이다. 하나의 프로젝트 안에서.

*프로젝트 빌드와 빌드도구
*Gradle 빌드 도구를 이용하여 프로젝트 폴더 준비
    빌드 : Application 만들기 위해 수행하는 개발과정을 통칭
        개발과정 : 컴파일, 테스트, 패키징(.jar, .war 만드는 과정), API문서 생성, 배포(deploy=배치), 프로젝트 폴더 준비
            .jar : java archive : class파일들의 모음
            .war : web archive
        빌드할 때마다 직접 명령 실행하면 너무 번거롭다 >>> 빌드 자동화
        빌드작업을 기술한 파일 >>로딩>> 빌드도구 : 빌드 작업을 순서대로 일괄적으로 수행
            빌드작업을 기술한 파일 : 빌드 스크립트 파일
                script : 명령문을 작성할 때 사용하는 간단한 프로그래밍 언어
*빌드 도구
    1. Ant
    >>> build.xml (=Ant의 빌드스크립트 파일)
    

    2. Maven
    >>> Ant빌드도구를 쓰다가 Maven으로 바꿨다. 그 이유는?
            +의존 라이브러리 관리 자동화
    >>> pom.xml (=Maven의 빌드스크립트 파일)
    >>> 단점 : xml이 태그기반 문법이다. >> 조건문, 반복문을 사용하기 힘들다.


    3. Gradle : Android studio의 기본 빌드 도구
    >>> Maven의 단점 때문에 다들 Gradle로 바꾸는 추세
    >>> 빌드스크립트를 XML 대신 GROOVY (=프로그래밍 언어) 사용
    >>> 프로그래밍 언어의 문법을 이용하여 빌드작업을 좀 더 정밀하게 제어할 수 있다.
    >>> build.gradle (= gradle의 빌드스크립트 파일)

즉, 택배상자(package)딱 뜯었을 때 제일 먼저 나오는 '사용설명서' 같은 존재(..?)
******------------------------------------------------------------------------------******
설치 : Gradle.org - installing manually - binary-only >>>환경변수 편집해서 PATH에 gradle\..\bin까지 경로설정
------------------------------------------------------
DSL (Domain-Specific Language = 특정도메인 언어 = 특정영역에서 쓰는 언어)
    ex)
        JSP : Java
        build.gradle(빌드스크립트) : groovy(주류), kotlin
---------------
* 실행 파일
app.com : 기계어                                    $ app 하면
app.exe : 기계어  >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>   app.com ~ app.exe ~ app.bat 순으로 찾아서 실행한다
app.bat : 스크립트 명령문                           단, 윈도우일 경우에만

unix일 경우 : app >> 실행권한부여 ($ chmod 755 app) RWXRWXRWX (: Read, Write, X실행)
                                              111_101_101 = 755 >>> 나, 그룹, 손님 순서로 읽고 쓰고 실행하는 권한
                                        그리고 그것을 보고 싶으면 ($ls -al) : 숨김파일을 포함하여 목록 자세히 출력 (ls 명령의 옵션)
                                                        ($ ./app) >>>>>>>>> 여기까지 해야 실행됨 (권한을 부여하고, 실행하는 과정이었음) (./ : 현재폴더 아래에 라는 뜻)

7/7----------------------------------------------------------------------------------------------------------------
*리터럴과 메모리크기
<정수>
주류----100 >> 4 byte 2진수 >> 01100100 (8bit)
                    >> 000...0_01100100 (0이 24개앞에 있고 01100100)
                    >> 16진수 >> 0x00_00_00_64
        100L >> 8 byte 2진수 >> 0x00_00_00_00_00_00_00_64

<부동소수점>
주류----12.375 >> 8 byte 2진수 >> 0x40_28_c0_00_00_00_00_00

        12.375f >> 4 byte 2진수 >> 0x41_46_00_00
    ** f를 붙여주면 이 수를 4byte로 바꾸라는 명령 **

<문자>
    'A' >> 2byte 2진수로 변환 >> 0x0041
    '가' >> 0xac00

<논리값>
    true >> 4byte 2진수로 변환 >> 0x00_00_00_01
    false >> 0x00_00_00_00
    단, 논리배열인 경우 1byte로 변환
        true >> 0x01
        false >> 0x00

<문자열>
    "ABC" >> String 클래스에 정의된 대로 그 형식에 맞춰 변환(걔가 따로 몇 byte인지 정해줌)



*메모리 크기와 값의 범위
<정수>
4 byte 정수 리터럴 : 약 -21억 ~ 21억
8 byte 정수 리터럴 : 약 -900경 ~ 900경

<부동소수점>
single precision(단정도) (=float)     32 bit >> 유효자릿수 7자리까지 '거의' 정상적으로 저장
double precision(배정도) (=double)    62 bit >> 유효자릿수 15자리까지 '거의' 정상적으로 저장
------------------------------------
* 문자와 코드
CR : Carriage Return
LF : Line Feed

* 줄바꿈 코드
Windows 에서는 CR (1byte), LF(1byte) >>합쳐서>> 0D0A
Unix 에서는 LF(1byte) >> 0A

* 문자 리터럴
'A', '가'
'\uAC00' = '\uac00' = 가 (즉, 대소문자를 구분하지 않는다.)

* 문자-코드-폰트
-문자 >> -Unicode >> -Arial -굴림체 -궁서체
'A' >>      0x41 >>     A    A      A
'가' >>     0xAC00 >>   x   가      가

    즉, 폰트 파일에 해당코드의 문자그림이 없으면 출력할 수 없다.


* 폰트
1. (모눈종이에 두고 그리는 것처럼) 픽셀단위로 그리는 방식 = Raster 방식
    = Raster 폰트
        - 픽셀 단위로 그린다
        - 그림크기 확대하면 계단현상 발생함
        - 출력속도는 빠르다

2. 점과 점을 연결하고 특정 수학식에 따라 그리는 방식 = Vector 방식
    = Vector 폰트 = Truetype 폰트
        - 계산하여 그린다.
        - 그림크기 확대해도 미려하게 출력가능
        - 계산이 필요하기 때문에 출력속도 느리다.

* 비트맵과 vector 이미지
비트맵 : Raster 방식
        Raster 방식의 특징 그대로 계승 + 파일크기가 크다
        .bmp .gif .jpg

벡터이미지 : Vector 방식
        Vector 방식의 특징 그대로 계승 + 파일크기가 작다(명령어로 이루어져 있음)
        클립아트

!!! 주의 !!! : 그림이 복잡하면 벡터명령이 많아지기 때문에 파일크기도 비트맵보다 더 커질 수 있다.

---------------------------------------------------------
* 변수 선언 : 메모리를 준비시키는 명령
    변수 : 값을 저장할 메모리
        데이터유형 메모리이름;
        DataType 변수명;
    ex) int n;

자바 원시 타입 (primitive type) : byte, short, int, long, float, double, boolean, char

* 변수에 값 저장하기(= assignment 하기)
        변수명 = 리터럴; ex) i = 100;
  또는  변수명 = 변수명; ex) j = i;
  또는  변수명 = 명령문; ex) s = i+j;
                명령문 = statement >>값을 리턴하는 명령문>> Expression(표현식)
                                                        명령문 실행을 완료하면 값을 리턴
-------------------------------------------------------------
* process와 메모리
java.exe : 컴파일러 프로그램
            프로그램 = application s/w
                이 app을 실행시키면 java.exe는 프로세스(= 실행중인 프로그램 = 실행중인 app)가 된다.

1. process가 OS에게 [실행되는 동안 데이터를 보관할 때 사용할 메모리를 달라고 요청] 한다.
2. OS가 H/W인 RAM에서 빼오는걸 허락함.
3. process가 메모리를 사용.

JVM은 OS에게 할당받은 메모리를 크게 3구획으로 나눠서 관리한다.
1. Method Area
2. JVM Stack (스레드 당 하나)
3. Heap

"=" : assignment operator : 할당/배정/대입 연산자
l-value : 변수"만" 올 수 있다.
r-value : 변수, 리터럴, expression 이 올 수 있다.

* 변수 선언

7/8-----------------------------------------------------------------------------------------------------
.java 파일이 javac.exe에 의해 컴파일되면 >>>> .class파일이 생성됨.(=바이트코드)
            - UTF-8, MS949                   - 이는 UTF-16BE(=유니코드)

>>>>>> JVM은 무조건 UTF-16BE로 변환해서 실행함 >>>>>>>> 실행할때 OS가 다시 UTF-8이나 MS949로 바꿔줌.

-------------------------------
%d : 10진수의 format을 가짐 (d : decimal)
%s : 문자열의 format을 가짐 (s : string)

7/11-----------------------------------------------------------------------------------------------------
Firmware : ROM 칩 안에 설치된 S/W

(SSD)HDD >> track >> Sector(=512 Byte/1sector) ---- 이 안에 OS 설치됨
    OS의 핵심기능 = 커널 (=Kernel)
        커널을 로딩한다 = OS를 로드한다.
전원을 키면 > ROM의 Firmware를 실행 >> 부트섹터에 있는 OS Loader를 실행 >> OS의 Kernel( : H/W관리)을 실행
    >>>>>>>>> 이 과정이 '부팅'

(메인보드에 설치된) BIOS : Boot Sector의 S/W를 실행시켜주는 프로그램 + H/W를 실행하는 프로그램

명령문 : statement
결과를 생성하는 문장 : expression

* 블록과 변수
1) '{'안에 있는 변수는 '}'를 만나면 소멸당한다.
2) 같은 {}블럭 안에 있는 변수들은 같은 이름으로 선언할 수 없다.
3) 블럭을 벗어나면 사용할 수 없다.


명시적 형변환 = type conversion = type casting

-----------------------------
* java :
    1) 변수의 타입은 변경할 수 없다
    2) 정적 타입 바인딩 = 고정형 타입 바인딩
  javascript :
    1) 값을 저장할 때 변수의 타입이 결정된다.
    2) 다른 타입의 값을 저장하면 변수의 타입도 바뀐다.
    3) 동적 타입 바인딩

-----------------------------
* 서로 다른 타입의 데이터를 계산
[int 연산자 float]
    int -> float 한 후, [float 연산자 float]를 계산

int i=5;
int j=2;
int z = i / (float) j;
    i를 float로 임시 형변환 후 float + float 계산 후, ( <<== implicit conversion )
        z를 int로..

------------------------------
* 클래스와 메서드
class Math {        // 수학관련 메서드를 분류한 class (=도구를 담아두는 도구함)
    abs(){--}       // 수학 관련 메서드 (=수단, 방법, 도구)
    round(){--}
    max(){--}
    min(){--}
    ...
}

7/12----------------------------------------------------------------------------
* expression : statement 이지만 결과를 리턴하는 statement를 한정해서 부르는 말

    int j = i++;

    위 문장은 컴파일될 때 다음과 같은 형태로 변환된다.
    int temp = i;
    i = i + 1;
    int j = temp;

* Buffer : 키보드에서 입력한 키 값을 임시 보관하는 메모리

nextInt() : 버퍼에서 숫자만 쏙 빼가서 읽음 (1 2 3 (enter)) >> 1 2 3 을 읽고 (enter)가 남음
    이거 지워줄려고 nextLine()을 써서 지움
        nextLine() : (enter)를 만날 때까지 데이터를 읽어들임

* System Integration (시스템 통합) : SI
    - 기존 시스템(= Legacy) 에 새로 개발한 시스템(= 새 기능)을 연동(= 통합)

* System Maintenance : SM
    - 기능변경, 추가, 삭제
    - 버그패치

7/13--------------------------------------------------------------------------------
* 도구함(클래스)의 도구(메서드)를 쓰기 위한 준비
    Math.abs(값)
        abs는 별도의 데이터를 준비할 필요없이 바로 사용가능한 도구다. ============ static mathod
        = 이런 도구는 도구함 이름으로 바로 사용할 수 있다.
    값 :
        도구를 실행하는데 필요한 값 = parameter = argument

    Date.getYear()
        이 도구는 그냥 사용할 수 없다. Date도구함을 이용해서 데이터를 준비한 후에 사용할 수 있다. ============= instance method

* 인스턴스 메서드 사용하려면~~
    1) 도구 사용전 데이터 준비(설정) :
        Date d = new Date();
            new : 도구함의 도구를 쓸 수 있도록 설정하기
            d : 설정된 데이터를 가리키는 변수
    2) 설정된 정보를 가지고 도구 실행
        d.getYear()
            d : 설정된 정보를 가리키는 변수 (= 참조변수 = reference)

* 일반 변수와 배열 변수
int[] arr;
    : 메모리 주소가 저장됨, 변수의 크기는 특정되지 않음

arr = new int[3];
    : 연속된 int 메모리,
        arr : 메모리의 주소를 저장하는 변수 = reference
        int[3] : new 명령을 통해 준비한 메모리 = 배열 instance


* 배열 레퍼런스와 배열 인스턴스
int[] arr = new int[3];
    인스턴스에 소속된 변수는 기본값이 자동으로 설정된다.
        정수 >> 0
        부동소수점 >> 0.0
        논리 >> false
        문자 >> \u0000
            >>>> 모든것은 0으로

* 메모리의 주소를 잃어버려 사용할 수 없는 인스턴스
= 메모리만 차지 = garbage(쓰레기)
        >>  1) cpu가 한가할 때
            2) 메모리가 부족할 때
            garbage를 제거한다. "garbage collector"가.
                *** JVM을 종료하면 JVM이 사용했던 모든 메모리를 OS가 강제로 해제시킨다. ***

* Garbage와 레퍼런스 카운트
레퍼런스 카운트 : 인스턴스의 주소를 갖고있는 레퍼런스의 개수
레퍼런스 카운트가 0인 인스턴스 = Garbage
레퍼런스 (= 포인터pointer (c에서))


* final
    : 원래의 특성을 변경한다 = modifier

7/14--------------------------------------------------------------------
* 메서드 ::: 코드를 유지보수하기 쉽게 기능 단위로 분리하기

void processBoardList() {....}

    processBoardList : 메서드명 >>> 행위를 나타내는 동사구 형태의 이름
    () : 파라미터 목록 >>> 작업 수행에 필요한 데이터를 받을 변수
    {....} : 메서드 몸체(=body) >>> 작업을 수행하는 코드
    void : 리턴 타입 >>> 작업 완료후 결과 값의 리턴 여부
            void : 값을 리턴 안함
            그 외 다른것 : 리턴하는 값의 타입


* 메서드에 묶인 코드 실행하기 = 메서드 호출 = 메서드 call
    명명 : 맨첫글자 소문자, 그 뒤 단어 첫글자 대문자


    변수 = 메서드명(값, 값, ...);

    메서드명 : 실행할 메서드
    값, 값, ... : 메서드 파라미터에 전달할 값 = argument
    변수 : 메서드가 값을 리턴할 경우, 그 값을 받을 변수------------(값을 받지 않아도 된다.)


    메서드는 정의, 변수는 선언

* 메서드를 통해 코드의 복잡함을 감춘다. ==>> encapsulation(캡슐화)

----------------------------------
* 클래스 사용 : 역할에 따라 메서드를 분류하기
    명명 : 명사, 명사구, 가끔 형용사 형태로 (동사형은 x)
    단어마다 전부 대문자시작


* 컴파일 옵션 : -sourcepath 소스폴더
    javac -encoding UTF-8 -d bin/main -sourcepath src/main/java src/main/java/com/bitcamp/board/App.java

    -sourcepath : 소스파일에서 참조하는 클래스가 있는 파일의 경로를 알려준다.


* 클래스 관계도
App --------> BoardHandler

    App : client
    BoardHandler : dependency : 의존객체
** 쌍방참조가 일어나서는 안된다. ** 절대로 **

** class는 resposibility 하다. (= 클래스는 책임을 갖고 있다. 역할을 갖고있다.)

------------------------------------------
* Eclipse Integrated Development Environment (IDE)
통합 개발 환경

* whitespace : space, tap, newline

* eclipse IDE 를 import하려면~~
    eclipse 설정파일이 프로젝트 폴더에 있어야 한다. 그래야 eclipse 프로젝트 폴더로 인식할 수 있다.

7/15------------------------------------------------------------------------------------
* UML (Unified Modeling Language) : 통합된 / 생각한 바를 글과 그림으로 표현하는 / 문법    

* new :
    ********** 도구함에 들어있는 도구를 사용하기 전에 필요 정보를 설정 **********

* Low Coupling : 관련된 클래스를 줄여라!
* High Cohesion : 한 클래스가 가능한 한개의 역할을 수행하도록/ 응집력, 집중도를 높여라!

* General Responsible Assignment Software Patterns : GRASP 패턴
    객체지향의 근본 패턴


-----------------------------------------------------
* 사용자 정의 데이터 타입

* 클래스 문법
    1) 메서드를 분류
    2) 데이터 타입 정의

* 새 데이터 타입 정의

1)  class Board {
        int no;
        String title;
        String content;
    }


2)  new Board()
            : 라고 하면~~ Board설계도에 따라 변수를 준비한다. 마치 배열메모리처럼(?)
        b.no = ~~ : 이렇게 쓴대

--------------------------------------------
Board b1 = new Board();

b1.no = 100;
// b배열의 0번째가 아니라
// b배열의 no번째에 100을 넣어라.

--------------------------------------------

* primitive type 변수의 배열과 레퍼런스 배열

    int[] arr = new int[3];

        arr : 레퍼런스
    
    -------------------
    Board[] arr = new Board[3];
        Board b1, b2, b3; // 레퍼런스가 3개 만들어진다. 인스턴스가 3개 만들어지는것이 아니다.

    arr[0] = new Board(); // 인스턴스 1개 생성 // 여러개 만들고 싶으면 이 과정을 반복문으로 반복하는 수밖에 없다.
        arr[0] : 레퍼런스 변수


    arr[1].no = 100; // arr[1]에 있는 주소로 가서 (거기에 또 배열이 있다) no번째에 100을 저장한다.



* String[] names = new String[28];
names[0] = "조주연"; // new String("조주연");이라고 써야하지만 생략가능

