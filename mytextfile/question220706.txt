ex04 /*
exam0422 : 
  // 주의!
    //- 유효자릿수가 15자리를 넘어가면 정상적으로 값을 저장되지 않을 수 있다.
    d = 9.999_999_999_999_997; // 맨 뒤의 값이 반올림 되거나 잘린다.
    System.out.println(d);

실행결과 : 9.999999999999996
이 값은 맨 끝의 997을 반올림 한것도 아니고(!=998) 잘린것도 아니다(!=99, !=997)
무슨 연유로 996이라는 끝자리가 나왔을까??

  d = 999999999999999.7; // 맨 뒤의 값이 반올림 되거나 잘린다.
    System.out.println(d);

위의 경우 실행결과 : 9.999999999999998E14
로 반올림한 값이 나왔다.





exam0423 :
public class Exam0423 {
  public static void main(String[] args) {

    float f;            // 이 줄을 >> double f; 로
    double d;

    // 변수도 크기에 따라 구분되지만, 리터럴도 크기에 따라 구분된다.
    // - 부동소수점 리터럴 값 뒤에 f나 F를 붙이면, 4바이트 크기의 부동소수점 값을 의미한다.
    // - 부동소수점 리터럴 값 뒤에 d나 D를 붙이거나 아무것도 붙이지 않으면, 8바이트 크기의 부동소수점 값을 의미한다.

    f = 9999.888f; // 4바이트 변수 = 4바이트 리터럴
    System.out.println(f);                      // 결과값 : 9999.888


    d = 99999999.8888888; // 8바이트 변수 = 8바이트 리터럴
    System.out.println(d);                      // 결과값 : 9.99999998888888E7

위 결과에서 이상한 점은 전혀 없다.
그러나 처음 변수 선언시
float f;
double d;
부분을
double f;
double d;
로 바꾸어 주었을 때는 System.out.println(f); 의 결과값이 9999.8876953125 로 출력된다.
게다가 vscode에서 빨간줄을 그어주지도 않고(문법에 맞지 않다는 힌트도 없고 ).java파일을 이용해서 컴파일도 잘 되었다는 뜻이다.
Q) f = 9999.888f 로 initialize 할 때 앞의 double f; 때문에 오류가 발생해야 하지 않는가?
혼자 생각하기 : double f; 로 선언된 변수 f에는 8바이트 리터럴이 들어갈 수 있다. 때문에 9999.888f 를 f변수에 넣더라도 문제가 없으므로 컴파일이 가능하다.
                출력이 이상하게 되는 것은...IEEE-754규칙에 문제가 있는걸까? 잘 모르겠다.
                다음 예제에서 답을 얻었다.

 // 4바이트 부동소수점을 8바이트 메모리에 저장할 때
    // 계산 방식에 의해 소수점 이하의 수가 근사 값으로 바뀐다.
    // => 8바이트 메모리에 값을 저장할 때는 8바이트 리터럴을 사용하라.

라고 한다.




exam0451 :
컴파일불가
가 아니라 컴파일은 되었다고 한다. 다만 경고문구가 뜰 뿐

uses or overrides a deprecated API.
Recompile with -Xlint:deprecation for details.

라는 문구로...

실행도 잘 된다.
6, 6
22, 22
라는 값으로...





