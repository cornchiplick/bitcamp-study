6/29------------------------------------------------------------------------------------
<인터프리터 언어>
소스파일을 읽어서 실행, 실행속도가 느리다.
명렁어를 실행하기 전에는 명렁문에 오류가 있는지 알수 없다.- 버그가 발견되기 어려움
소스코드가 노출 > 프로그래밍 자산 보호 불가능

<자바>
Hybrid 프로그래밍 > 컴파일형식+인터프리트형식
자바 캐치프레이즈>>> write once, run anywhere > 한번만 작성하고, 어디서든 작동함 >>>> 인터프리터 언어의 장점
:
문법오류 검사,
[명령문 최적화>실행명령수가 감소>실행속도향상],
[가상기계어로 변환>소스노출을 막음>프로그래밍 자산을 보호],

bytecode player = java runtime = **JVM**(Java Virtual Machine)
-------------------------------------------------
Bytecode 실행 한계 극복
JIT(Just-In-Time)컴파일 : 실행할 일부 코드를 뭉텅이로 가져와서 기계어로 변환하고 즉시 실행.
<<----->>
// ART(Android Run Time) AOT(Ahead Of Time)컴파일 : 안드로이드에 주로 씀>>앱 설치할때 모든 코드를 기계어로 변환 후 저장함.
------------------------------------------------
Emulator(변환기) : 다른타입의 언어를 맞는 언어로 변환해 줌 ex.(intel>>ARM 변환기)
<JDK 종류>
Open JDK > Oracle JDK > GraalVM
         > IBM JDK
         > Amazon JDK
         > Azul JDK
------------------------------------------------

자바 문법 : 기본 구조
* 소스파일-클래스 블록-.class 파일
* 공개(public)로 설정된 클래스 블록인 경우 파일명은 클래스 블록 이름과 같아야 한다. >> public class는 단 하나만 존재함
6/30--------------------------------------------------------------------------------------
*entry point : main(){~~} : 진입점
jVM이 명령문 실행을 시작하는 곳
>>
class Exam03 {
    public static void main(String[]args) {
        __명령문__
    }
}
>> 의 형식을 가진다
--------------------------------------------
*자바 문법
1) literal //데이터 표기법
2) variable //메모리 준비
3) operators //데이터 연산자
4) 흐름제어문 //조건, 반복문
5) 메소드 //명령어 묶음
6) 클래스 //메소드 묶음
-----------------------
*literal : 데이터 표기법
6  = 0b0110 (=0B0110) (2진수) //b:binary
10 = 012 (8진수) //0:octa
18 = 0x12 (= 0X12) (16진수)
----------
고정 소수점 : 3.14
부동 소수점 : 31.4^10^-1 = 31.4E-1 = 31.4e-1
----------
논리값 : true false //대소문자 구분
----------
문자 : 'A' '가' //UTF : Unicode TransForm
encoding(~형식화 하라=코드화) <-> decoding(~로 복원하라) //코드화 한걸 풀어 = codec (=en*co*ding + *dec*oding)
//동영상 압축 방법 : MPEG, H.264, ...VP9 //방법 : algorithm
----------
문자열 : "ABCDE", "가나다", --> double quotation 사용! (single quotation 은 안됨) + "" = 빈 '문자열' // '' = 빈 문자...가!!! 아니다!!! 오류임!! // " " = ' ' = 스페이스 문자
single quotation은 문자 '하나'만 가능! // 'a'는 문자, "a"는 문자열
----------
*주석은 컴파일에서 제외된다.(=.class파일에 포함되지 않는다. = .class의 크기와는 상관 없음) : 코드에 대한 부가설명(자신이나 다른 개발자의 이해를 돕기위해)
// : 한 줄 주석 : 줄 끝 까지
/* ....~~~.... */ : 여러줄 주석
----------
*variables : 메모리를 준비시키는 명령문 (메모리를 준비시키는 이유 : 데이터를 저장하기 위해)
저장할 데이터의 유형(data type), 메모리를 가리키는 이름(variable name)
ex) int age; //int : data type, age : variable name
ㄴ=> 정수값을 담을 4byte 크기의 메모리를 준비하라! >> 준비된 메모리를 지금부터 age라 부르겠다., ; : 문장의 끝 표시
**'메모리를 준비시키는 명령문'을 '변수 선언(=variable declaration)'이라 부른다.**
----------
*data type : (자바언어에서 기본으로 제공하는 데이터타입=**primitive data type**=자바 원시 데이터타입=자바 기본 데이터타입)
|| 정수(integer) --------> [1byte:byte], [2byte:short], [4byte:int], [8byte:long]
||부동소수점(floating point) --------> [4byte:float], [8yte:double]
||논리(boolean) ---------> [4byte메모리 기본사용:boolean(배열을 만들 때는 1byte로 만든다.)]
||문자(character) --------> [2byte:char] >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> 이 네 종류가 java primitive data type
문자열(string) ---------> [객체:String] >>>>>>>>>>>>>>>>>>>>>>>>>> 클래스
-----------------------
*변수선언
---------
*Assignment 연산자 : 변수(준비한 메모리)에 값 저장 :
변수명/*(메모리이름=변수선언할 때 지정한 이름)*/ =/*(assignment operation=할당연산자)*/ 값/*리터럴, 변수명 가능*/; //== : equal 연산자
ex1) int a;
a=100; //100 : 정수 리터럴 값
ex2) int b;
b=a; //a변수에 들어있는 **값인 100**을 b변수에 저장하라!
-------------
*메모리 크기와 값의 범위
byte b;
b = 값;
여기서 값은 -128 ~ +127 의 범위
-------------
*메모리크기와 값 저장
ms949? cpu949? -- 검색해보기
-------------
*정수를 2진수로 표현하는 다양한 방법
1) sign-Magnitude : 부호1bit, magnitude(절대값) 나머지 bit : 부동소수점을 2진수로 바꾸는 과정에서 가수부를 표현할때 사용!!
2) 1's 보수 : 안씀!!
    +4 = 0100
    -4 = 0100 에 대해 1의 보수 (보수 : 그 수가 되기 위해 보충해줘야 하는 수) 를 취해서
         1011 이 -4가 된다. //overflow 수는 버린다!!
3) 2의 보수 : 자바에서 정수를 2진수로 바꿀때 사용하는 규칙!! (+대부분의 프로그래밍 언어가 이 규칙 사용)
    +4 = 0100
    -4 : 0100 에 대해 1의 보수해서 1011
        에 다시 1을 더해서 1100
4) Excess -k : 초과하다 bias(여분으로 초과하는 값) : 부동소수점을 2진수로 바꾸는 과정에서 지수부를 표현할 때 사용!!
    +4 : 4 + 128 = 132 >> 132를 2진수로 >> 10000100
    -4 : -4 + 128 = 124 >> 124를 2진수로 >> 01111100
    
    k값은 2^(비트수-1)-1 = 2^(4-1)-1 = 8-1 = 7 (4bit메모리 기준)
    따라서
    +4 >> 4+7 = 11 >> 1011
    -4 >> -4+7 = 3 >> 0011
7/1--------------------------------
*부동소수점을 2진수로 표현하는 방법 >>> IEEE-754 규칙
12.375
12 --> 1100
0.375 --> 0.375*2=0.75 --> 0
        0.75*2=1.5 --> 1
        0.5*2=1.0 --> 1
    ==>> 0.011
===>>> 12.375 = 1100.011 = 1.100011 * 2^3
>> 소수 왼쪽은 무조건 1임 그래서 버림
>> 부호비트 1비트 +:0, -:1
>> 지수(exponent)부 8비트 : Excess-k 규칙에 따라 2진수화 시킨다.
>> 가수(mantissa)부 23비트 --> sign-magnitude 규칙에 따라 2진수로바꾼다.

*2진수와 16진수의 관계
2진수 4bit면 16진수로 바꿈
-------------------------------
*문자를 2진수로 표현하는 방법
1. ASCII : **미국표준**
7bit로 정의 >> 최대 128자

2. (1.)+유럽문자 : ISO-8859-1 (ISO-latin-1) : 8bit >> 최대 256자 : 영어, 숫자, 특수문자 + 유럽문자 : **국제표준**

3. EUC-KR (KSC-5601) : 2byte : **국제표준**
> 영어 : ISO-8859-1 : 1byte
> 한글 : 2byte
가 >> 1011 0000 1010 0001 >> B0A1
각 >> 1011 0000 1010 0010 >> B0A2
똘 >> 1011 0110 1100 1010 >> B6CA
똠 >> x
똥 >> 1011 0110 1100 1011 >> B6CB
>>>> 최대 65536자, 한글은 2350자, 나머지는 일본, 중국어, ...

4. 조합형 : 2byte : **기업이 만들었고 국가표준이지만 국제표준은 아님**
[초성]
ㄱ >> 00010
ㄲ >> 00011
ㄴ >> 00100
...

[중성]
ㅏ >> 00011
ㅐ >> 00100
ㅑ >> 00101
...

[종성]
ㄱ >> 00010
ㄲ >> 00011
ㄳ >> 00100
...

댄 = 1 00101 00100 00101 >> 1001 0100 1000 0101 >> 0x9485

5. MS949(CP949) : 2byte = [EUC-KR] + [약 8천자] 규칙을 추가 // 개 어거지로 추가함 ㅋ
>> 11172자 정의 >> 현재 쓰고 있음 >> ANSI

6. Unicode (2byte, 4byte) //java는 2바이트 씀 >> = UTF-16
A >> 0041
B >> 0042
가 >> AC00
각 >> AC01
...
: 한글11172자 + 옛한글, ...

A >>BE>> 0041 >>LE>> 4100
각 >>BE>> AC01 >>LE>> 01AC

>>> 영어권 입장에서는 데이터 2배로 많이 써서 문제제기


7. UTF-8 : 유니코드 변형 규칙 : 8bit로 표현할 수 있는 문자는 예전처럼 그대로 8bit로 표현하기 >> 그 외 문자는 규칙에 따라 변형하자!
    >> 한글은 2byte 였는데 3byte로 늘어나버림
    가 >> AC00 >> 1010 1100 0000 0000 (UNICODE)
        >>  1110 ~~~~ 10~~~~~~ 10~~~~~~
        >> 1110 1010 1011 0000 1000 0000 (UTF-8)
        >> E A B 0 8 0 >> 0xEAB080

>>> 그러나 JVM이 문자를 저장할 때는 unicode를 쓴다. 그러나 국제표준은 UTF-8을 쓴다.
    일반적으로 텍스트를 저장할 때는 UTF-8을 쓴다.
---------------
*텍스트 와 바이너리
text : .txt, .java, .html, .css, .js, .xml ==>> 문자변환규칙에 따라 저장된 파일 >> 메모장으로 편집가능!
binary : .doc, .hwp, .pdf, .avi, .mp3, .jpg, .gif ==>> 전용 S/W를 통해서만 편집가능!

위에서 말한 문자변환규칙 = character set (= 문자집합)
----------------------------------------------------------
*논리값을 2진수로 표현하는 법
true --> 0000 0001 (1)
false --> 0000 0000 (0)
>> 4byte로 저장한다!

단! 배열인 경우 : 1byte만 사용함!
true --> 01
false --> 00
7/4-----------------------------------------------------------------------------
java se(standard edition) 가 있어야 java ee(enterprise edition)도 이용가능함.
-----------------------------
<windows용>  ==> <mac용>
dir >> ls
%PATH% >> $PATH // % % 인데 $만 씀
---------------------------
nano .zshrc
export JAVA_HOME=`/usr/libexec/java_home -v 17` <<=== ~표시임 따옴표 아님 = "backtick"
# ~~~~~~ ==>> 주석이라는 뜻
export PATH=${JAVA_HOME}/bin:$HOME/bin:/usr/local/bin:$PATH
^X ==>> 컨트롤 키 누르고 X 하라는 뜻 // Exit와 같다
echo $JAVA_HOME  // 경로나옴
echo $PATH // PATH 경로나옴
javac -version
java -version
--------------------------
// JAVA_HOME 환경변수 설정하는 이유 : 일부 java app은 실행할 때 jdk나 jre가 설치된 폴더의 위치를 조회하는 경우가 있다.
// PATH 환경변수에 프로그램 폴더 경로를 등록하는 이유 : 명령 프롬프트의 디렉토리 위치에 상관없이 자바 개발도구를 실행할 수 있도록 하기 위함.
7/5---------------------------------------------------------------------------
JDK : Java Development Kit
JRE : Java Runtime Environment
------------------------------------------------
git clone https://github.com/cornchiplick/bitcamp-study // github.com에 있는 repo를 local로 복제해옴.
git add Hello.java // 백업 명단에 파일을 등록한다. (=staged 상태)
git add . // 현재 폴더부터 하위폴더까지 뒤져서 새로 추가되는걸 전부 git add함
git commit -m "백업이유" // 백업 명단에 등록된 파일이나 폴더를 로컬저장소에 백업한다. (=snapshot 상태)
